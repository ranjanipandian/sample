"""
Query Service for Research Intelligence Search Platform
Provides semantic, keyword, and Q&A search capabilities
Uses PostgreSQL database with embeddings generated by Amazon Nova-2
"""

import os
import numpy as np
import psycopg2
from psycopg2.extras import RealDictCursor
from sklearn.metrics.pairwise import cosine_similarity
from dotenv import load_dotenv
import re
from datetime import datetime
import json
import boto3

# Load environment variables
load_dotenv()

# Database Configuration
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '5432')
DB_USER = os.getenv('DB_USER', 'postgres')
DB_PASSWORD = os.getenv('DB_PASSWORD')
DB_NAME = os.getenv('DB_NAME', 'research_kb')

# AWS Bedrock Configuration for Nova-2 embeddings
AWS_PROFILE = os.getenv('AWS_PROFILE', 'default')
AWS_REGION = os.getenv('AWS_REGION', 'us-east-1')
AWS_MODEL_ID = os.getenv('AWS_MODEL_ID', 'amazon.nova-2-multimodal-embeddings-v1:0')

# Initialize AWS Bedrock client
try:
    session = boto3.Session(profile_name=AWS_PROFILE)
    bedrock_runtime = session.client(
        service_name='bedrock-runtime',
        region_name=AWS_REGION
    )
    print("‚úÖ AWS Bedrock client initialized successfully")
except Exception as e:
    print(f"‚ö†Ô∏è Warning: Could not initialize AWS Bedrock client: {e}")
    bedrock_runtime = None

# -------------------- Database Connection --------------------
def get_db_connection():
    """Create database connection"""
    try:
        conn = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            user=DB_USER,
            password=DB_PASSWORD,
            database=DB_NAME,
            cursor_factory=RealDictCursor
        )
        return conn
    except Exception as e:
        print(f"‚ùå Database connection error: {e}")
        return None

# -------------------- Keyword Search --------------------
def keyword_search(query, top_k=15, min_score=0.0):
    """
    Perform keyword-based search on file names and content
    Returns files that match keywords in the query
    """
    results = []
    
    try:
        conn = get_db_connection()
        if not conn:
            return results
        
        cursor = conn.cursor()
        
        # Split query into keywords
        keywords = query.lower().split()
        
        # Build SQL query to search in file_name and content_preview
        search_conditions = []
        for keyword in keywords:
            search_conditions.append(f"(LOWER(file_name) LIKE '%{keyword}%' OR LOWER(content_preview) LIKE '%{keyword}%')")
        
        sql_query = f"""
            SELECT file_name, file_path, file_type, file_size, file_modified, 
                   content_preview, embedding, embedding_dimension
            FROM document_embeddings
            WHERE {' OR '.join(search_conditions)}
            ORDER BY file_modified DESC
            LIMIT {top_k}
        """
        
        cursor.execute(sql_query)
        rows = cursor.fetchall()
        
        # Calculate simple keyword match score
        for row in rows:
            file_name_lower = row['file_name'].lower()
            content_lower = (row['content_preview'] or '').lower()
            
            # Count keyword matches
            match_count = sum(1 for kw in keywords if kw in file_name_lower or kw in content_lower)
            score = match_count / len(keywords) if keywords else 0
            
            if score >= min_score:
                results.append({
                    'file_name': row['file_name'],
                    'file_path': row['file_path'],
                    'file_type': row['file_type'],
                    'file_size': row['file_size'],
                    'file_modified': row['file_modified'],
                    'content_preview': row['content_preview'] or '',
                    'relevance_score': round(score, 3),
                    'search_type': 'keyword'
                })
        
        cursor.close()
        conn.close()
        
    except Exception as e:
        print(f"‚ùå Error in keyword search: {e}")
    
    return results

# -------------------- Generate Query Embedding with Nova-2 --------------------
def generate_query_embedding(query_text):
    """Generate embedding for query using Amazon Nova-2"""
    if not bedrock_runtime:
        print("‚ùå AWS Bedrock client not available")
        return None
    
    try:
        request_body = {
            "taskType": "SINGLE_EMBEDDING",
            "singleEmbeddingParams": {
                "embeddingPurpose": "GENERIC_INDEX",
                "embeddingDimension": 1024,
                "text": {
                    "truncationMode": "END",
                    "value": query_text[:8000]
                }
            }
        }
        
        response = bedrock_runtime.invoke_model(
            modelId=AWS_MODEL_ID,
            body=json.dumps(request_body),
            accept="application/json",
            contentType="application/json"
        )
        
        body = json.loads(response['body'].read())
        embedding = None
        
        if 'embedding' in body:
            embedding = body['embedding']
            if isinstance(embedding, dict) and 'embedding' in embedding:
                embedding = embedding['embedding']
        elif 'embeddings' in body:
            embedding = body['embeddings'][0]
            if isinstance(embedding, dict) and 'embedding' in embedding:
                embedding = embedding['embedding']
        
        return embedding
        
    except Exception as e:
        print(f"‚ùå Error generating query embedding: {e}")
        return None

# -------------------- Semantic Search --------------------
def semantic_search(query, top_k=10, min_score=0.30, use_llm=True):
    """
    Perform semantic search using GPT-4o to directly rank documents
    Understands synonyms, abbreviations, context, typos
    
    Args:
        query: Search query
        top_k: Number of results to return
        min_score: Minimum relevance score threshold
        use_llm: Always True (kept for compatibility)
    
    Returns:
        List of ranked results with relevance scores
    """
    
    # Use NEW GPT-4o semantic search implementation
    try:
        from gpt4o_semantic_search import gpt4o_semantic_search
        print(f"ü§ñ Using GPT-4o semantic search: '{query}'")
        results = gpt4o_semantic_search(query, top_k=top_k, min_score=min_score)
        return results
    except Exception as e:
        print(f"‚ùå GPT-4o semantic search failed: {e}")
        import traceback
        traceback.print_exc()
        return []

# -------------------- Hybrid Search (Not used but kept for compatibility) --------------------
def hybrid_search(query, top_k=10, min_score=0.3):
    """
    Combine keyword and semantic search results
    """
    keyword_results = keyword_search(query, top_k=top_k, min_score=0.0)
    semantic_results = semantic_search(query, top_k=top_k, min_score=min_score)
    
    # Merge results by file_path
    merged = {}
    
    for result in keyword_results:
        path = result['file_path']
        merged[path] = result
        merged[path]['keyword_score'] = result['relevance_score']
        merged[path]['semantic_score'] = 0.0
    
    for result in semantic_results:
        path = result['file_path']
        if path in merged:
            merged[path]['semantic_score'] = result['relevance_score']
            merged[path]['relevance_score'] = (merged[path]['keyword_score'] + result['relevance_score']) / 2
        else:
            merged[path] = result
            merged[path]['keyword_score'] = 0.0
            merged[path]['semantic_score'] = result['relevance_score']
    
    # Convert to list and sort
    results = list(merged.values())
    results.sort(key=lambda x: x['relevance_score'], reverse=True)
    
    return results[:top_k]

# -------------------- Advanced Search (Not used but kept for compatibility) --------------------
def advanced_search(query, top_k=10, min_score=0.3):
    """
    Advanced search with filtering options
    """
    return hybrid_search(query, top_k=top_k, min_score=min_score)

# -------------------- Main (for testing) --------------------
if __name__ == "__main__":
    print("=" * 70)
    print("üîç Query Service Test")
    print("=" * 70)
    
    # Test database connection
    conn = get_db_connection()
    if conn:
        print("‚úÖ Database connection successful")
        conn.close()
    else:
        print("‚ùå Database connection failed")
        exit(1)
    
    # Interactive query loop
    while True:
        print("\n" + "=" * 70)
        query = input("Enter your query (or 'exit' to quit): ").strip()
        if query.lower() == 'exit':
            break
        
        print("\nSearch type:")
        print("1. Keyword Search")
        print("2. Semantic Search")
        choice = input("Choose (1/2): ").strip()
        
        if choice == '1':
            print("\nÔøΩ Performing Keyword Search...")
            results = keyword_search(query, top_k=5)
        elif choice == '2':
            print("\nüß† Performing Semantic Search...")
            results = semantic_search(query, top_k=5)
        else:
            print("‚ùå Invalid choice")
            continue
        
        if results:
            print(f"\n‚úÖ Found {len(results)} results:")
            for i, result in enumerate(results, 1):
                print(f"\n{i}. {result['file_name']}")
                print(f"   Type: {result['file_type']}")
                print(f"   Path: {result['file_path']}")
                print(f"   Score: {result['relevance_score']:.3f}")
                print(f"   Preview: {result['content_preview'][:100]}...")
        else:
            print("\n‚ùå No results found")
